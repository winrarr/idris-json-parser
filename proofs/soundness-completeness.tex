% Soundness and completeness of the JSON parser (informal but rigorous)
\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\geometry{margin=1in}

\newcommand{\parse}{\mathsf{parse}}
\newcommand{\run}{\mathsf{runParser}}
\newcommand{\ws}{\mathsf{ws}}
\newcommand{\dq}{\texttt{"}}
\newcommand{\seq}{\mathbin{;}}

\title{Soundness and Completeness of the Idris2 JSON Parser}
\author{}
\date{}

\begin{document}
\maketitle

\section*{Overview}
We formalize the parser as a computation on strings and give a rigorous, but
still informal (non-mechanized), proof of soundness and completeness with
respect to the JSON grammar used by the parser. We assume the correctness of
primitive parser operations and treat them as axioms.

\section*{Definitions}

\paragraph{Parser semantics.}
A parser for values of type $A$ is a partial function
\[
  p : \Sigma^\ast \to \mathrm{Maybe}(A \times \Sigma^\ast),
\]
implemented as $\run(p, s)$. If $\run(p, s) = \mathrm{Just}(x, r)$ we say
$p$ succeeds on input $s$, consumes a prefix of $s$, yields $x$, and leaves
remainder $r$.

\paragraph{Axioms (model assumptions).}
We assume the following about strings, options, primitive parsers, and the
basic combinators. These are treated as axioms rather than proved from any
language implementation details.
\begin{enumerate}
  \item \textbf{Strings.} $\Sigma^\ast$ is the set of finite strings over an
  alphabet $\Sigma$ with standard concatenation.
  \item \textbf{Options.} $\mathrm{Maybe}(A)$ has constructors $\mathrm{Just}(a)$
  and $\mathrm{Nothing}$.
  \item \textbf{Primitive parsers.}
  \begin{enumerate}
    \item $\mathsf{char}(c)$ succeeds iff the next character is $c$, consuming
    exactly one character.
    \item $\mathsf{stringExact}(t)$ succeeds iff the input starts with $t$,
    consuming exactly $|t|$ characters.
    \item $\mathsf{satisfy}(P)$ succeeds iff the next character satisfies $P$,
    consuming exactly one character.
  \end{enumerate}
  \item \textbf{Combinators.}
  \begin{enumerate}
    \item \textbf{Sequencing.} $\run(p \seq q, s) = \mathrm{Just}(y, r')$ iff
    there exists $x,r$ such that $\run(p, s) = \mathrm{Just}(x, r)$ and
    $\run(q, r) = \mathrm{Just}(y, r')$.
    \item \textbf{Choice.} $\run(p <|> q, s) = \mathrm{Just}(x, r)$ iff either
    $\run(p, s) = \mathrm{Just}(x, r)$ or
    ($\run(p, s) = \mathrm{Nothing}$ and $\run(q, s) = \mathrm{Just}(x, r)$).
    \item \textbf{Repetition.} $\run(\mathsf{many}(p), s) = \mathrm{Just}(xs, r)$
    iff $s = s_0 r$ where $s_0$ is a concatenation of zero or more strings each
    accepted by $p$ in sequence and $\run(p, r) = \mathrm{Nothing}$ (maximal
    consumption); $\mathsf{some}(p)$ is the non-empty case.
    \item \textbf{Separated lists.} $\run(\mathsf{sepBy}(p, \mathsf{sep}), s) =
    \mathrm{Just}(xs, r)$ iff either $\run(p, s) = \mathrm{Nothing}$ and
    $xs = []$ with $r = s$, or $s = s_0 r$ where $s_0$ is a $p$-item followed
    by zero or more repetitions of $\mathsf{sep}$ then $p$, and
    $\run(\mathsf{sep} \seq p, r) = \mathrm{Nothing}$ (maximal consumption).
  \end{enumerate}
  We only use $\mathsf{many}$ and $\mathsf{sepBy}$ with parsers that do not
  accept the empty string, so the maximality conditions above are well-defined.
  \item \textbf{Whitespace.} Let $W = \mathrm{WS}^\ast$ (all whitespace strings).
  The parser $\ws$ always succeeds, consuming the longest prefix $w \in W$ and
  leaving the remaining suffix.
  \item \textbf{Lexemes.}
  \begin{enumerate}
    \item $\mathsf{keyword}(t)$ succeeds iff the input starts with $t$, and in
    that case consumes $t$ followed by the longest prefix in $W$.
    \item $\mathsf{comma}$ succeeds iff the input starts with $\texttt{","}$,
    and in that case consumes it followed by the longest prefix in $W$.
    \item $\mathsf{stringLiteral}$ succeeds iff the input starts with
    $\mathsf{stringCore}$, and in that case consumes it followed by the
    longest prefix in $W$, yielding the decoded string.
    \item $\mathsf{numberLiteral}$ succeeds iff the input starts with
    $\mathsf{numberCore}$, and in that case consumes it followed by the
    longest prefix in $W$, yielding the matched numeric lexeme.
  \end{enumerate}
  \item \textbf{String character class.} $\mathsf{stringChar}$ recognizes
  exactly the JSON string character class (unescaped non-control characters
  or valid escape sequences) and yields the decoded character.
\end{enumerate}

\paragraph{Top-level acceptance.}
\[
  \parse(p, s) = \mathrm{Just}(x)
  \iff \run(p, s) = \mathrm{Just}(x, r) \land r \in W
\]

\paragraph{Grammar (whitespace-extended).}
Let $\mathcal{G}$ be the grammar used by the parser. We separate core tokens
from lexemes that include trailing whitespace:
\[
\begin{array}{rcl}
\mathsf{value} &\to& W\ (\mathsf{object} \mid \mathsf{array} \mid \mathsf{string}
                     \mid \mathsf{number} \mid \mathsf{true} \mid \mathsf{false}
                     \mid \mathsf{null}) \\
\mathsf{object} &\to& \texttt{"\{"}\ W\ \mathsf{members}?\ \texttt{"\}"}\ W \\
\mathsf{members} &\to& \mathsf{member}\ (\mathsf{comma}\ \mathsf{member})^\ast \\
\mathsf{member} &\to& \mathsf{string}\ \texttt{":"}\ W\ \mathsf{value} \\
\mathsf{array} &\to& \texttt{"["}\ W\ \mathsf{elements}?\ \texttt{"]"}\ W \\
\mathsf{elements} &\to& \mathsf{value}\ (\mathsf{comma}\ \mathsf{value})^\ast \\
\mathsf{string} &\to& \mathsf{stringCore}\ W \\
\mathsf{number} &\to& \mathsf{numberCore}\ W \\
\mathsf{true} &\to& \texttt{"true"}\ W \\
\mathsf{false} &\to& \texttt{"false"}\ W \\
\mathsf{null} &\to& \texttt{"null"}\ W \\
\mathsf{comma} &\to& \texttt{","}\ W \\
\mathsf{stringCore} &\to& \dq\ \mathsf{char}^\ast\ \dq \\
\mathsf{numberCore} &\to& \texttt{"-"}?\ \mathsf{int}\ \mathsf{frac}?\ \mathsf{exp}? \\
\mathsf{int} &\to& \texttt{"0"} \mid \mathsf{digit1to9}\ \mathsf{digit}^\ast \\
\mathsf{frac} &\to& \texttt{"."}\ \mathsf{digit}^+ \\
\mathsf{exp} &\to& (\texttt{"e"} \mid \texttt{"E"})\ (\texttt{"+"} \mid \texttt{"-"})?\ \mathsf{digit}^+ \\
\mathsf{digit} &\to& \texttt{"0"} \mid \texttt{"1"} \mid \texttt{"2"} \mid \texttt{"3"} \mid \texttt{"4"} \mid \texttt{"5"} \mid \texttt{"6"} \mid \texttt{"7"} \mid \texttt{"8"} \mid \texttt{"9"} \\
\mathsf{digit1to9} &\to& \texttt{"1"} \mid \texttt{"2"} \mid \texttt{"3"} \mid \texttt{"4"} \mid \texttt{"5"} \mid \texttt{"6"} \mid \texttt{"7"} \mid \texttt{"8"} \mid \texttt{"9"} \\
\mathsf{char} &\to& \text{any unescaped non-control} \mid \text{escape sequence}
\end{array}
\]

\paragraph{Language semantics.}
For each nonterminal $X$ we define its language $L(X) \subseteq \Sigma^\ast$ as
follows:
\begin{enumerate}
  \item If $X \to t_1 t_2 \cdots t_n$ is a production, then any concatenation
  $s = s_1 s_2 \cdots s_n$ with $s_i = t_i$ for terminals and $s_i \in L(t_i)$
  for nonterminals belongs to $L(X)$.
  \item If $X \to Y \mid Z$, then $L(X) = L(Y) \cup L(Z)$.
  \item If a rule contains $R^\ast$ or $R^+$, then $L(R^\ast)$ is the set of all
  finite concatenations of strings in $L(R)$ (including empty), and $L(R^+)$ is
  the set of all non-empty such concatenations.
  \item If a rule contains $R?$, then $L(R?) = L(R) \cup \{\epsilon\}$.
\end{enumerate}
We treat $W$ as a distinguished nonterminal with language $\mathrm{WS}^\ast$,
as given by the axioms.

\paragraph{Parser specification (algorithm).}
We reason about the following parser equations, which describe the algorithm
independently of any implementation. We omit AST construction because it does
not affect input consumption.
\begin{enumerate}
  \item $\mathsf{jsonNull}$ parses $\mathsf{keyword}(\texttt{"null"})$.
  \item $\mathsf{jsonBool}$ parses $\mathsf{keyword}(\texttt{"true"}) <|>
  \mathsf{keyword}(\texttt{"false"})$.
  \item $\mathsf{jsonNumber}$ parses $\mathsf{numberLiteral}$.
  \item $\mathsf{jsonString}$ parses $\mathsf{stringLiteral}$.
  \item $\mathsf{objectField}$ parses
  $\mathsf{stringLiteral} \seq \mathsf{char}(\texttt{":"}) \seq \ws \seq
  \mathsf{jsonValue}$.
  \item $\mathsf{jsonArray}$ parses
  $\mathsf{char}(\texttt{"["}) \seq \ws \seq
  \mathsf{sepBy}(\mathsf{jsonValue}, \mathsf{comma}) \seq
  \mathsf{char}(\texttt{"]"}) \seq \ws$.
  \item $\mathsf{jsonObject}$ parses
  $\mathsf{char}(\texttt{"\{"}) \seq \ws \seq
  \mathsf{sepBy}(\mathsf{objectField}, \mathsf{comma}) \seq
  \mathsf{char}(\texttt{"\}"}) \seq \ws$.
  \item $\mathsf{jsonValue}$ parses $\ws \seq (\mathsf{jsonNull} <|>
  \mathsf{jsonBool} <|> \mathsf{jsonNumber} <|> \mathsf{jsonString} <|>
  \mathsf{jsonArray} <|> \mathsf{jsonObject})$.
\end{enumerate}

\section*{Soundness}

\paragraph{Theorem (Soundness).}
If $\parse(\mathsf{jsonValue}, s) = \mathrm{Just}(v)$, then $s \in L(\mathsf{value})$.

\paragraph{Proof.}
We prove soundness for the mutually recursive parsers
$\mathsf{jsonValue}$, $\mathsf{jsonArray}$, $\mathsf{jsonObject}$, and
$\mathsf{objectField}$ by mutual induction on their definitions, using the
axioms for primitives, lexemes, and combinators.

\paragraph{Lemma S1 (lexeme soundness).}
By Axioms 5 and 6, $\ws$, $\mathsf{keyword}$, $\mathsf{comma}$,
$\mathsf{stringLiteral}$, and $\mathsf{numberLiteral}$ consume the longest
prefixes in the languages of $W$, $\mathsf{true}$/$\mathsf{false}$/$\mathsf{null}$,
$\mathsf{comma}$, $\mathsf{string}$, and $\mathsf{number}$ respectively. By the
parser specification, $\mathsf{jsonNull}$, $\mathsf{jsonBool}$,
$\mathsf{jsonNumber}$, and $\mathsf{jsonString}$ consume the same languages.

\paragraph{Lemma S2 (object field soundness).}
$\mathsf{objectField}$ consumes a $\mathsf{string}$, then $\texttt{":"}$,
then $W$, then a $\mathsf{value}$. By Lemma S1, Axiom 3, and Axiom 4
(sequencing), and the mutual induction hypothesis that $\mathsf{jsonValue}$ is
sound for $\mathsf{value}$, its consumed prefix is in $L(\mathsf{member})$.

\paragraph{Lemma S3 (array soundness).}
$\mathsf{jsonArray}$ consumes $\texttt{"["}W$, then a $\mathsf{sepBy}$ list of
$\mathsf{value}$ separated by $\mathsf{comma}$, then $\texttt{"]"}W$.
By Lemma S1, Axiom 4 (sequencing and sepBy), and the mutual induction
hypothesis for $\mathsf{jsonValue}$, its consumed prefix is in
$L(\mathsf{array})$.

\paragraph{Lemma S4 (object soundness).}
$\mathsf{jsonObject}$ consumes $\texttt{"\{"}W$, then a $\mathsf{sepBy}$ list of
$\mathsf{member}$ separated by $\mathsf{comma}$, then $\texttt{"\}"}W$.
By Lemmas S1 and S2 and Axiom 4, its consumed prefix is in
$L(\mathsf{object})$.

\paragraph{Lemma S5 (value soundness).}
$\mathsf{jsonValue}$ consumes $W$ then chooses among parsers for
$\mathsf{object}$, $\mathsf{array}$, $\mathsf{string}$, $\mathsf{number}$,
$\mathsf{true}$, $\mathsf{false}$, or $\mathsf{null}$. By Lemmas S1, S3, S4 and
Axiom 4 (choice), any success yields a prefix in $L(\mathsf{value})$.

The lemmas are mutually consistent, so by mutual induction the soundness of
$\mathsf{jsonValue}$ holds. With top-level acceptance, the theorem follows; any
residual $r \in W$ can be appended to a string in $L(\mathsf{value})$ without
leaving the language because $W$ is closed under concatenation. \qed

\section*{Completeness}

\paragraph{Theorem (Completeness).}
If $s \in L(\mathsf{value})$, then there exists $v$ such that
$\parse(\mathsf{jsonValue}, s) = \mathrm{Just}(v)$.

\paragraph{Proof.}
We prove completeness for the same mutually recursive parsers by mutual
induction on the grammar, using the axioms.

\paragraph{Lemma C1 (lexeme completeness).}
By Axioms 5 and 6, $\ws$, $\mathsf{keyword}$, $\mathsf{comma}$,
$\mathsf{stringLiteral}$, and $\mathsf{numberLiteral}$ consume the longest
prefixes in the languages of $W$, $\mathsf{true}$/$\mathsf{false}$/$\mathsf{null}$,
$\mathsf{comma}$, $\mathsf{string}$, and $\mathsf{number}$ respectively. By the
parser specification, $\mathsf{jsonNull}$, $\mathsf{jsonBool}$,
$\mathsf{jsonNumber}$, and $\mathsf{jsonString}$ consume the same languages.

\paragraph{Lemma C2 (object field completeness).}
If $s \in L(\mathsf{member})$, then by the grammar $s$ is a concatenation of
a $\mathsf{string}$, $\texttt{":"}$, $W$, and a $\mathsf{value}$. By Lemma C1 and
Axiom 4 (sequencing), and the mutual induction hypothesis that
$\mathsf{jsonValue}$ is complete for $\mathsf{value}$, $\mathsf{objectField}$
succeeds on $s$.

\paragraph{Lemma C3 (array completeness).}
If $s \in L(\mathsf{array})$, then $s$ matches $\texttt{"["}W$, then a possibly
empty list of $\mathsf{value}$ separated by $\mathsf{comma}$, then $\texttt{"]"}W$.
By Lemma C1, Axiom 4 (sepBy), and the mutual induction hypothesis for
$\mathsf{jsonValue}$, $\mathsf{jsonArray}$ succeeds on $s$.

\paragraph{Lemma C4 (object completeness).}
If $s \in L(\mathsf{object})$, then $s$ matches $\texttt{"\{"}W$, then a possibly
empty list of $\mathsf{member}$ separated by $\mathsf{comma}$, then $\texttt{"\}"}W$.
By Lemmas C1 and C2 and Axiom 4, $\mathsf{jsonObject}$ succeeds on $s$.

\paragraph{Lemma C5 (value completeness).}
If $s \in L(\mathsf{value})$, then by the grammar $s$ is in $W$ followed by one
of the alternatives. By Lemmas C1--C4 and Axiom 4 (choice), $\mathsf{jsonValue}$
succeeds on $s$; left bias does not prevent success because choice succeeds
whenever at least one branch succeeds.

The lemmas are mutually consistent, so by mutual induction the completeness of
$\mathsf{jsonValue}$ holds. Because the grammar for each alternative already
includes trailing $W$ and $\ws$ consumes the leading whitespace prefix,
$\mathsf{jsonValue}$ consumes the entire input $s$ when
$s \in L(\mathsf{value})$, leaving $r = \epsilon \in W$. With top-level
acceptance, the theorem follows. \qed

\section*{Notes}
This document presents a rigorous, axiomatic proof in mathematical prose; it is
not mechanically verified. A machine-checked proof would require a
formalization of these axioms in a proof assistant.

\end{document}
