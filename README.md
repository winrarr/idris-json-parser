# Idris2 JSON + YAML Parser

A small, self-contained JSON parser (RFC 8259) and a practical YAML subset parser in Idris2. JSON is implemented via a minimal parser combinator library and a hand-written grammar. YAML is implemented via a line/indentation-aware parser that maps into the same JSON AST.

## What This Is

- A tiny parser combinator core (`Parser/Core.idr`).
- Reusable combinators (`Parser/Combinators.idr`).
- JSON AST and pretty printer (`Parser/JSON/Types.idr`).
- JSON grammar and parser (`Parser/JSON/Parser.idr`).
- YAML subset parser (`Parser/YAML/Parser.idr`).
- CLI entry points: JSON (`MainJSON.idr`), YAML (`MainYAML.idr`), and auto-detect (`Main.idr`).

## What The Solution Is Based On

- **RFC 8259 JSON grammar**: The parser follows the standard JSON productions (object, array, number, string, true/false/null). Numbers support optional fraction and exponent; strings support standard escapes and `\uXXXX` (including surrogate pairs).
- **Recursive descent via combinators**: The grammar is encoded as mutually recursive parsers (`jsonValue`, `jsonObject`, `jsonArray`, etc.) with choice and sequencing.
- **Algebraic structure of parsers**:
  - **Functor**: `map` transforms the parsed value without changing how much input was consumed (defined for completeness; not currently used).
  - **Applicative**: sequencing independent parsers with `<*>` and `pure`.
  - **Monad**: `do`-notation chains parsers where later steps depend on earlier results.
  - **Choice (`<|>`)**: try the left parser first; if it fails, try the right one.
  - **Combinators**: `many`/`some` (Kleene star/plus), `sepBy`, and `ws` build up the grammar from primitives.

## Rationale

We model parsing as a function from an input string to either failure or a successful result paired with the unconsumed suffix. This choice makes parsing a computation that both produces a value and tracks remaining input, a structure that naturally supports composition.

From this model follow three fundamental composition laws:

1. **Mapping results (Functor)**  
   If a parser produces a value, we can transform that value without affecting how much input was consumed. This captures the idea that syntax and meaning are separable: parsing recognizes structure; mapping assigns meaning.

2. **Sequencing (Applicative / Monad)**  
   To parse a compound structure, we run one parser, then feed its remaining input to another. Applicative sequencing describes fixed‑shape combinations (e.g., parse `"{"`, then parse members, then parse `"}"`). Monad sequencing handles dependencies where later parsing depends on earlier results (e.g., parse an escape sequence that determines how to interpret the next characters).

3. **Alternation (Choice)**  
   Many grammars have multiple valid productions (alternatives). A choice operator `p <|> q` expresses “try `p`; if it fails, try `q`,” implementing the disjunction in a grammar rule. Because the choice is left‑biased, order matters if alternatives can overlap; JSON’s grammar is designed to be unambiguous, but the implementation still reflects this left‑to‑right priority.

The JSON specification (RFC 8259) gives a grammar. Each grammar production is translated into a parser by structural recursion:

1. **Terminals** (`"{"`, `"true"`, digits) become primitive parsers that consume specific characters or character classes.
2. **Concatenation** (e.g., `member = string ":" value`) becomes sequencing of parsers.
3. **Alternation** (e.g., `value = object | array | string | number | "true" | "false" | "null"`) becomes choice.
4. **Repetition** (`1*digit`, `*( "," member )`) becomes higher‑order combinators like `many`, `some`, and `sepBy`.

This is the essence of recursive‑descent parsing via combinators: the algorithm is generated by the structure of the grammar, not by ad‑hoc control flow. Each definition is a compositional translation of a grammar rule, so the algorithm is the grammar expressed as code. At the top level, the parser accepts only if the entire input is consumed (ignoring JSON whitespace for JSON parsing), enforcing a complete parse rather than a prefix match.

## Why This Works

The parser combinator approach is correct by construction: each combinator preserves the semantics of parsing defined by the model. Because sequencing and choice obey the laws of the underlying algebra, complex parsers built from these operations inherit the behavior of their parts in a principled way. The “logic” therefore comes from:

- The formal model of parsing as String → Maybe (A, String).
- The algebraic laws of Functor/Applicative/Monad/Alternative.
- The grammar in RFC 8259, translated structurally into combinators.

## File Layout

- `Parser/Core.idr`: core parser type + Functor/Applicative/Monad + primitive parsers.
- `Parser/Combinators.idr`: `many`, `some`, `ws`, `sepBy`.
- `Parser/JSON/Types.idr`: `JSON` data type + `Show` implementation.
- `Parser/JSON/Parser.idr`: JSON grammar + `parseJSON`.
- `MainJSON.idr`: JSON-only CLI entry point.
- `MainYAML.idr`: YAML-only CLI entry point.
- `Main.idr`: auto-detect CLI entry point (JSON first, then YAML).
- `samples/`: example JSON files.
- `tests/run_samples.sh`: quick smoke test runner.

## Build

```
idris2 MainJSON.idr -o jsonparser
idris2 MainYAML.idr -o yamlparser
idris2 Main.idr -o autoparser
```

Binary output:

```
build/exec/jsonparser
build/exec/yamlparser
build/exec/autoparser
```

## Run

From a file with the JSON parser:

```
build/exec/jsonparser samples/sample-valid.json
```

From a file with the YAML parser:

```
build/exec/yamlparser samples/sample-valid.yaml
```

From stdin with the auto parser (content-based detection: JSON first, then YAML):

```
cat samples/sample-valid.json | build/exec/autoparser
```

From a file with the auto parser:

```
build/exec/autoparser samples/sample-valid.yaml
```

## Notes

- Numbers are kept as their original literal string (`JNumber String`) to avoid precision loss.
- YAML subset: block mappings/sequences, plain/single/double-quoted scalars, literal (`|`) and folded (`>`) block scalars, comments, and single-line flow collections. Advanced YAML features (anchors, tags, complex keys, multi-document streams) are intentionally not supported.
- The soundness/completeness proofs apply to the JSON parser only.
