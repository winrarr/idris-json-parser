# Idris2 JSON Parser

A small, self-contained JSON parser in Idris2. It implements the JSON grammar from RFC 8259 using a minimal parser combinator library and a hand-written grammar.

## What This Is

- A tiny parser combinator core (`Parser/Core.idr`).
- Reusable combinators (`Parser/Combinators.idr`).
- JSON AST and pretty printer (`Parser/JSON/Types.idr`).
- JSON grammar and parser (`Parser/JSON/Parser.idr`).
- A CLI entry point (`Main.idr`).

## What The Solution Is Based On

- **RFC 8259 JSON grammar**: The parser follows the standard JSON productions (object, array, number, string, true/false/null). Numbers support optional fraction and exponent; strings support standard escapes and `\uXXXX` (including surrogate pairs).
- **Recursive descent via combinators**: The grammar is encoded as mutually recursive parsers (`jsonValue`, `jsonObject`, `jsonArray`, etc.) with choice and sequencing.
- **Algebraic structure of parsers**:
  - **Functor**: `map` transforms the parsed value without changing how much input was consumed (defined for completeness; not currently used).
  - **Applicative**: sequencing independent parsers with `<*>` and `pure`.
  - **Monad**: `do`-notation chains parsers where later steps depend on earlier results.
  - **Choice (`<|>`)**: try the left parser first; if it fails, try the right one.
  - **Combinators**: `many`/`some` (Kleene star/plus), `sepBy`, and `ws` build up the grammar from primitives.

## Rationale

We model parsing as a function from an input string to either failure or a successful result paired with the unconsumed suffix. This choice makes parsing a computation that both produces a value and tracks remaining input, a structure that naturally supports composition.

From this model follow three fundamental composition laws:

1. **Mapping results (Functor)**  
   If a parser produces a value, we can transform that value without affecting how much input was consumed. This captures the idea that syntax and meaning are separable: parsing recognizes structure; mapping assigns meaning.

2. **Sequencing (Applicative / Monad)**  
   To parse a compound structure, we run one parser, then feed its remaining input to another. Applicative sequencing describes fixed‑shape combinations (e.g., parse `"{"`, then parse members, then parse `"}"`). Monad sequencing handles dependencies where later parsing depends on earlier results (e.g., parse an escape sequence that determines how to interpret the next characters).

3. **Alternation (Choice)**  
   Many grammars have multiple valid productions (alternatives). A choice operator `p <|> q` expresses “try `p`; if it fails, try `q`,” implementing the disjunction in a grammar rule. Because the choice is left‑biased, order matters if alternatives can overlap; JSON’s grammar is designed to be unambiguous, but the implementation still reflects this left‑to‑right priority.

The JSON specification (RFC 8259) gives a grammar. Each grammar production is translated into a parser by structural recursion:

1. **Terminals** (`"{"`, `"true"`, digits) become primitive parsers that consume specific characters or character classes.
2. **Concatenation** (e.g., `member = string ":" value`) becomes sequencing of parsers.
3. **Alternation** (e.g., `value = object | array | string | number | "true" | "false" | "null"`) becomes choice.
4. **Repetition** (`1*digit`, `*( "," member )`) becomes higher‑order combinators like `many`, `some`, and `sepBy`.

This is the essence of recursive‑descent parsing via combinators: the algorithm is generated by the structure of the grammar, not by ad‑hoc control flow. Each definition is a compositional translation of a grammar rule, so the algorithm is the grammar expressed as code. At the top level, the parser accepts only if the entire input is consumed (ignoring trailing whitespace), enforcing a complete parse rather than a prefix match.

## Why This Works

The parser combinator approach is correct by construction: each combinator preserves the semantics of parsing defined by the model. Because sequencing and choice obey the laws of the underlying algebra, complex parsers built from these operations inherit the behavior of their parts in a principled way. The “logic” therefore comes from:

- The formal model of parsing as String → Maybe (A, String).
- The algebraic laws of Functor/Applicative/Monad/Alternative.
- The grammar in RFC 8259, translated structurally into combinators.

## File Layout

- `Parser/Core.idr`: core parser type + Functor/Applicative/Monad + primitive parsers.
- `Parser/Combinators.idr`: `many`, `some`, `ws`, `sepBy`.
- `Parser/JSON/Types.idr`: `JSON` data type + `Show` implementation.
- `Parser/JSON/Parser.idr`: JSON grammar + `parseJSON`.
- `Main.idr`: CLI entry point.
- `samples/`: example JSON files.
- `tests/run_samples.sh`: quick smoke test runner.

## Build

```
idris2 Main.idr -o jsonparser
```

Binary output:

```
build/exec/jsonparser
```

## Run

From a file:

```
build/exec/jsonparser samples/sample-valid.json
```

From stdin:

```
cat samples/sample-valid.json | build/exec/jsonparser
```

## Notes

- Numbers are kept as their original literal string (`JNumber String`) to avoid precision loss.
